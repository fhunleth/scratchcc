defmodule CodeTemplate do
  require EEx
  EEx.function_from_string :def, :generate, """
/* AUTOGENERATED FILE - DO NOT MODIFY */
<%= for include <- Enum.uniq(context.includes) do %>
#include <%= include %>
<% end %>

<%= for global <- Enum.uniq(context.globals) do %>
<%= global %>
<% end %>

<%= for block <- Enum.reverse(context.code) do %>
<%= block %>
<% end %>

void setup()
{
<%= for initcall <- Enum.uniq(context.initcode) do %>
    <%= initcall %>
<% end %>
}

void loop()
{
<%= for poll <- Enum.uniq(context.pollcalls) do %>
    <%= poll %>
<% end %>
}
""", [:context]
end


defmodule Scratchcc do

  defmodule Context do
    defstruct includes: [],
              globals: [],
              pollcalls: [],
              initcode: [],
              code: [],
              scope_name: [],
              scope_counter: 0
  end

  def doit(input, output) do
    contents = gen_from_file(input)
    File.write(output, contents)
  end

  def gen_from_file(filename) do
    {:ok, contents} = File.read(filename)
    gen_from_json(contents)
  end

  def gen_from_json(json) do
    {:ok, project} = JSEX.decode(json)
    %Context{}
      |> gen_project(project)
      |> CodeTemplate.generate
  end

  defp gen_project(context, project) do
    context
      # Generate the stage
      |> gen_object(project)
      # Generate all the sprites
      |> gen_objects(project["children"])
  end

  def gen_objects(context, []) do
    context
  end
  def gen_objects(context, [obj | rest]) do
    context
      |> gen_object(obj)
      |> gen_objects(rest)
  end

  def gen_object(context, obj) do
    context
      |> push_scope_name(obj["objName"])
      |> gen_variables(obj["variables"])
      |> gen_scripts(obj["scripts"])
      |> pop_scope_name
  end

  @doc """
  Generate code for the "scripts" value for the both sprites and
  the stage.
  """
  def gen_scripts(context, nil) do
    context
  end
  def gen_scripts(context, []) do
    context
  end
  def gen_scripts(context, [script | scripts]) do
    context
      |> gen_script(script)
      |> gen_scripts(scripts)
  end

  @doc """
  Generate code for one script.
  """
  def gen_script(context, [x, y, cmds]) do
    # TODO: figure out something on the scope_name
    context
      |> push_scope_name("_#{x}_#{y}")
      |> gen_script_thread(cmds)
      |> pop_scope_name
  end

  defp gen_variables(context, nil) do
    context
  end
  defp gen_variables(context, []) do
    context
  end
  defp gen_variables(context, [var | rest]) do
    context
      |> gen_variable(var)
      |> gen_variables(rest)
  end

  defp gen_variable(context, varmap) do
    gen_variable(context, varmap["name"], varmap["value"])
  end
  defp gen_variable(context, <<"#out", pin :: binary>>, _value) do
    context
      |> add_init_code("pinMode(#{pin}, OUTPUT);")
  end

  defp push_scope_name(context, name) do
    %{context | :scope_name => [name | context.scope_name]}
  end

  defp pop_scope_name(context) do
    %{context | :scope_name => tl(context.scope_name)}
  end

  defp add_include(context, include_file) do
    %{context | :includes => context.includes ++ [include_file]}
  end

  defp add_global(context, declaration) do
    %{context | :globals => context.globals ++ [declaration]}
  end

  defp add_poll_call(context, call) do
    %{context | :pollcalls => context.pollcalls ++ [call]}
  end

  defp add_init_code(context, code) do
    %{context | :initcode => context.initcode ++ [code]}
  end

  defp push_code(context, code) do
    %{context | :code => [code | context.code]}
  end

  defp pop_code(context) do
    code = hd(context.code)
    new_context = %{context | :code => tl(context.code)}
    {new_context, code}
  end

  defp scope_name(context) do
    Enum.reduce(context.scope_name, "", &Kernel.<>/2)
  end

  defp var_prefix(context) do
    "#{scope_name(context)}_#{context.scope_counter}"
  end

  defp inc_scope(context) do
    %{context | :scope_counter => context.scope_counter + 1}
  end

  @doc """
  Generate the appropriate thread based on the "hat" block in the script
  """
  def gen_script_thread(context, [["whenGreenFlag"] | body]) do
    prefix = scope_name(context)
    context = context
      |> add_include("\"pt.h\"")
      |> add_global("static struct pt #{prefix}_pt;")
      |> add_init_code("PT_INIT(&#{prefix}_pt);")
      |> add_poll_call("#{prefix}_thread(&#{prefix}_pt);")
      |> gen_script_body(body)

    {context, body_code} = pop_code(context)
    code = """
    PT_THREAD(#{prefix}_thread(struct pt *pt))
    {
        PT_BEGIN(pt);
        #{body_code}
        PT_WAIT_UNTIL(pt, 0);/* PT_END will restart, so wait forever */
        PT_END(pt);
    }
    """

    context |> push_code(code)
  end
  def gen_script_thread(context, _blocks) do
    # Ignore all other unrecognized scratch "hat" blocks. These usually
    # aren't hat blocks and are just random blocks hanging around while
    # writing the scratch program
    context
  end

  def gen_script_body(context, blocks) do
    saved_code = context.code
    context = %{context | code: []}
      |> gen_script_body_impl(blocks)
    new_code = List.foldl(context.code, "", &Kernel.<>/2)
    %{context | code: [new_code | saved_code]}
  end

  defp gen_script_body_impl(context, []) do
    context
  end
  defp gen_script_body_impl(context, [block | rest]) do
    context
      |> gen_script_block(block)
      |> inc_scope
      |> gen_script_body(rest)
  end

  @doc """
  Generate the code for a non-hat block.
  See http://wiki.scratch.mit.edu/wiki/Scratch_File_Format_(2.0)/Block_Selectors
  for the list of selectors.
  """
  def gen_script_block(context, ["-", a, b]) do
    gen_script_binary_op(context, "-", a, b)
  end
  def gen_script_block(context, ["+", a, b]) do
    gen_script_binary_op(context, "+", a, b)
  end
  def gen_script_block(context, ["*", a, b]) do
    gen_script_binary_op(context, "*", a, b)
  end
  def gen_script_block(context, ["/", a, b]) do
    gen_script_binary_op(context, "/", a, b)
  end
  def gen_script_block(context, ["&", a, b]) do
    gen_script_binary_op(context, "&&", a, b)
  end
  def gen_script_block(context, ["%", a, b]) do
    gen_script_binary_op(context, "%", a, b)
  end
  def gen_script_block(context, ["<", a, b]) do
    gen_script_binary_op(context, "<", a, b)
  end
  def gen_script_block(context, ["=", a, b]) do
    gen_script_binary_op(context, "==", a, b)
  end
  def gen_script_block(context, [">", a, b]) do
    gen_script_binary_op(context, ">", a, b)
  end
  def gen_script_block(context, ["|", a, b]) do
    gen_script_binary_op(context, "||", a, b)
  end
  def gen_script_block(context, x) when is_integer(x) do
    context |> push_code(Integer.to_string(x))
  end
  def gen_script_block(context, x) when is_float(x) do
    context |> push_code("#{x}f")
  end
  def gen_script_block(context, x) when is_binary(x) do
    context |> push_code("\"#{x}\"")
  end
  def gen_script_block(context, ["sqrt", x]) do
    context = context |> gen_script_block(x)
    {context, param_code} = pop_code(context)
    context |> push_code("sqrt(#{param_code})")
  end
  def gen_script_block(context, ["abs", x]) do
    context = context |> gen_script_block(x)
    {context, param_code} = pop_code(context)
    context |> push_code("abs(#{param_code})")
  end
  def gen_script_block(context, ["say:", x]) do
    context = context |> gen_script_block(x)
    # TODO: if x is a int, then turn it into a string for this call
    {context, param_code} = pop_code(context)
    context
      |> add_init_code("Serial.begin(9600);")
      |> push_code("Serial.write(#{param_code});")
  end
  def gen_script_block(context, ["doForever", loop_contents]) do
    context = context |> gen_script_body(loop_contents)
    {context, loop_code} = pop_code(context)
    if String.length(loop_code) > 0 do
      context |> push_code("for (;;) {\n#{loop_code}\n}")
    else
      context |> push_code("PT_WAIT_UNTIL(pt, 0); /* Empty doForever loop */\n")
    end
  end
  def gen_script_block(context, ["setVar:to:", varname, value]) do
    context = context |> gen_script_block(value)
    {context, value_code} = pop_code(context)
    context |> gen_var_set(varname, value_code)
  end
  def gen_script_block(context, ["wait:elapsed:from:", seconds]) do
    context = context |> gen_script_block(seconds)
    {context, code} = pop_code(context)
    gen_wait_millis_code(context, "1000 * (#{code})")
  end
  def gen_script_block(context, ["setTempoTo:", tempo]) do
    context = context |> gen_script_block(tempo)
    {context, code} = pop_code(context)
    context
      |> add_tempo_var
      |> push_code("#{tempo_var(context)} = constrain(#{code}, 20, 500);\n")
  end
  def gen_script_block(context, ["changeTempoBy:", delta]) do
    context = context |> gen_script_block(delta)
    {context, code} = pop_code(context)
    context
      |> add_tempo_var
      |> push_code("#{tempo_var(context)} = constrain(#{tempo_var(context)} + (#{code}), 20, 500);\n")
  end
  def gen_script_block(context, ["tempo"]) do
    context
      |> add_tempo_var
      |> push_code("#{tempo_var(context)}")
  end
  def gen_script_block(context, ["instrument:", _instrument]) do
    # The arduino doesn't support instruments
    context
      |> push_code("")
  end
  def gen_script_block(context, ["noteOn:duration:elapsed:from:", note, duration]) do
    context = context
      |> gen_script_block(note)
      |> gen_script_block(duration)
    {context, duration_code} = pop_code(context)
    {context, note_code} = pop_code(context)
    freqtable = "scratch_to_freq_table"
    context
      |> add_tempo_var
      |> add_global(Notes.c_array(freqtable))
      |> push_code("tone(6, #{freqtable}[constrain(#{note_code},0,sizeof(#{freqtable})/sizeof(#{freqtable}[0]))]);\n")
      |> gen_wait_millis_code("60000 * (#{duration_code}) * 9 / (10 * #{tempo_var(context)})")
      |> push_code("noTone(6);\n")
      |> gen_wait_millis_code("60000 * (#{duration_code}) / (10 * #{tempo_var(context)})")
  end
  def gen_script_block(context, ["rest:elapsed:from:", duration]) do
    context
      |> add_tempo_var
      |> gen_wait_millis_code("60000 * (#{duration}) / #{tempo_var(context)}")
  end

  defp gen_wait_millis_code(context, millis_code) do
    waitvar = "#{scope_name(context)}_waittime"
    context
      |> add_global("static unsigned long #{waitvar};")
      |> push_code("#{waitvar} = millis() + (#{millis_code});\nPT_WAIT_UNTIL(pt, millis() - #{waitvar} < 10000);\n")
  end

  defp tempo_var(context) do
    "#{scope_name(context)}_tempo"
  end

  defp add_tempo_var(context) do
      add_global(context, "static unsigned long #{tempo_var(context)} = 60; /* Scratch default bpm */")
  end

  defp gen_var_set(context, <<"#out", pin :: binary>>, value_code) do
    context
      |> push_code("digitalWrite(#{pin}, #{gpio_value(value_code)});\n")
  end

  defp gpio_value("\"high\""), do: "HIGH"
  defp gpio_value("\"High\""), do: "HIGH"
  defp gpio_value("\"HIGH\""), do: "HIGH"
  defp gpio_value("\"low\""), do: "LOW"
  defp gpio_value("\"Low\""), do: "LOW"
  defp gpio_value("\"LOW\""), do: "LOW"
  defp gpio_value(x) when is_integer(x) and x > 0, do: "HIGH"
  defp gpio_value(x) when is_integer(x) and x == 0, do: "LOW"
  # Sometimes Scratch puts integers into strings in JSON.
  defp gpio_value(str) when is_binary(str) do
    str
      |> String.lstrip(?")
      |> String.rstrip(?")
      |> String.to_integer
      |> gpio_value
  end

  defp gen_script_binary_op(context, binary_op, a, b) do
    context = context
      |> gen_script_block(a)
      |> gen_script_block(b)
    {context, b_code} = pop_code(context)
    {context, a_code} = pop_code(context)
    context |> push_code("((#{a_code}) " <> binary_op <> "(#{b_code}))")
  end

end
